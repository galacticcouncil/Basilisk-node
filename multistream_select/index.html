<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Multistream-select Protocol Negotiation"><meta name="keywords" content="rust, rustlang, rust-lang, multistream_select"><title>multistream_select - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e963ab4a0d0c903e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-046227e470cd3629.css"><link rel="stylesheet" disabled href="../static.files/dark-800f2ee593c8e6f7.css"><link rel="stylesheet" disabled href="../static.files/ayu-9edae3c387f5a5b3.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-287cecec4dbb45b0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../multistream_select/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../multistream_select/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate multistream_select</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.11.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">multistream_select</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/multistream_select/lib.rs.html#21-148">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="multistream-select-protocol-negotiation"><a href="#multistream-select-protocol-negotiation">Multistream-select Protocol Negotiation</a></h2>
<p>This crate implements the <code>multistream-select</code> protocol, which is the protocol
used by libp2p to negotiate which application-layer protocol to use with the
remote on a connection or substream.</p>
<blockquote>
<p><strong>Note</strong>: This crate is used primarily by core components of <em>libp2p</em> and it
is usually not used directly on its own.</p>
</blockquote>
<h3 id="roles"><a href="#roles">Roles</a></h3>
<p>Two peers using the multistream-select negotiation protocol on an I/O stream
are distinguished by their role as a <em>dialer</em> (or <em>initiator</em>) or as a <em>listener</em>
(or <em>responder</em>). Thereby the dialer plays the active part, driving the protocol,
whereas the listener reacts to the messages received.</p>
<p>The dialer has two options: it can either pick a protocol from the complete list
of protocols that the listener supports, or it can directly suggest a protocol.
Either way, a selected protocol is sent to the listener who can either accept (by
echoing the same protocol) or reject (by responding with a message stating
“not available”). If a suggested protocol is not available, the dialer may
suggest another protocol. This process continues until a protocol is agreed upon,
yielding a <a href="struct.Negotiated.html"><code>Negotiated</code></a> stream, or the dialer has run out of
alternatives.</p>
<p>See <a href="fn.dialer_select_proto.html"><code>dialer_select_proto</code></a> and
<a href="fn.listener_select_proto.html"><code>listener_select_proto</code></a>.</p>
<h3 id="negotiated"><a href="#negotiated"><code>Negotiated</code></a></h3>
<p>A <code>Negotiated</code> represents an I/O stream that has settled on a protocol
to use. By default, with <a href="enum.Version.html#variant.V1" title="Version::V1"><code>Version::V1</code></a>, protocol negotiation is always
at least one dedicated round-trip message exchange, before application
data for the negotiated protocol can be sent by the dialer. There is
a variant <a href="enum.Version.html#variant.V1Lazy" title="Version::V1Lazy"><code>Version::V1Lazy</code></a> that permits 0-RTT negotiation if the
dialer only supports a single protocol. In that case, when a dialer
settles on a protocol to use, the <a href="type.DialerSelectFuture.html" title="DialerSelectFuture"><code>DialerSelectFuture</code></a> yields a
<a href="struct.Negotiated.html"><code>Negotiated</code></a> I/O stream before the negotiation
data has been flushed. It is then expecting confirmation for that protocol
as the first messages read from the stream. This behaviour allows the dialer
to immediately send data relating to the negotiated protocol together with the
remaining negotiation message(s). Note, however, that a dialer that performs
multiple 0-RTT negotiations in sequence for different protocols layered on
top of each other may trigger undesirable behaviour for a listener not
supporting one of the intermediate protocols. See
<a href="fn.dialer_select_proto.html"><code>dialer_select_proto</code></a> and the documentation
of <a href="enum.Version.html#variant.V1Lazy" title="Version::V1Lazy"><code>Version::V1Lazy</code></a> for further details.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>For a dialer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::net::TcpStream;
<span class="kw">use </span>multistream_select::{dialer_select_proto, Version};
<span class="kw">use </span>futures::prelude::<span class="kw-2">*</span>;

async_std::task::block_on(<span class="kw">async move </span>{
    <span class="kw">let </span>socket = TcpStream::connect(<span class="string">&quot;127.0.0.1:10333&quot;</span>).<span class="kw">await</span>.unwrap();

    <span class="kw">let </span>protos = <span class="macro">vec!</span>[<span class="string">b&quot;/echo/1.0.0&quot;</span>, <span class="string">b&quot;/echo/2.5.0&quot;</span>];
    <span class="kw">let </span>(protocol, _io) = dialer_select_proto(socket, protos, Version::V1).<span class="kw">await</span>.unwrap();

    <span class="macro">println!</span>(<span class="string">&quot;Negotiated protocol: {:?}&quot;</span>, protocol);
    <span class="comment">// You can now use `_io` to communicate with the remote.
</span>});</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ListenerSelectFuture.html" title="multistream_select::ListenerSelectFuture struct">ListenerSelectFuture</a></div><div class="item-right docblock-short">The <code>Future</code> returned by <a href="fn.listener_select_proto.html" title="listener_select_proto"><code>listener_select_proto</code></a> that performs a
multistream-select protocol negotiation on an underlying I/O stream.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Negotiated.html" title="multistream_select::Negotiated struct">Negotiated</a></div><div class="item-right docblock-short">An I/O stream that has settled on an (application-layer) protocol to use.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NegotiatedComplete.html" title="multistream_select::NegotiatedComplete struct">NegotiatedComplete</a></div><div class="item-right docblock-short">A <code>Future</code> that waits on the completion of protocol negotiation.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.NegotiationError.html" title="multistream_select::NegotiationError enum">NegotiationError</a></div><div class="item-right docblock-short">Error that can happen when negotiating a protocol with the remote.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ProtocolError.html" title="multistream_select::ProtocolError enum">ProtocolError</a></div><div class="item-right docblock-short">A protocol error.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Version.html" title="multistream_select::Version enum">Version</a></div><div class="item-right docblock-short">Supported multistream-select versions.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dialer_select_proto.html" title="multistream_select::dialer_select_proto fn">dialer_select_proto</a></div><div class="item-right docblock-short">Returns a <code>Future</code> that negotiates a protocol on the given I/O stream
for a peer acting as the <em>dialer</em> (or <em>initiator</em>).</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.listener_select_proto.html" title="multistream_select::listener_select_proto fn">listener_select_proto</a></div><div class="item-right docblock-short">Returns a <code>Future</code> that negotiates a protocol on the given I/O stream
for a peer acting as the <em>listener</em> (or <em>responder</em>).</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.DialerSelectFuture.html" title="multistream_select::DialerSelectFuture type">DialerSelectFuture</a></div><div class="item-right docblock-short">Future, returned by <code>dialer_select_proto</code>, which selects a protocol and dialer
either trying protocols in-order, or by requesting all protocols supported
by the remote upfront, from which the first protocol found in the dialer’s
list of protocols is selected.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="multistream_select" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (234151769 2022-12-03)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>