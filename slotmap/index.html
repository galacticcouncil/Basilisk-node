<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="slotmap"><meta name="keywords" content="rust, rustlang, rust-lang, slotmap"><title>slotmap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e963ab4a0d0c903e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-046227e470cd3629.css"><link rel="stylesheet" disabled href="../static.files/dark-800f2ee593c8e6f7.css"><link rel="stylesheet" disabled href="../static.files/ayu-9edae3c387f5a5b3.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-287cecec4dbb45b0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../slotmap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../slotmap/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate slotmap</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.6</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">slotmap</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/slotmap/lib.rs.html#1-606">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="slotmap"><a href="#slotmap">slotmap</a></h2>
<p>This library provides a container with persistent unique keys to access
stored values, <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a>. Upon insertion a key is returned that can be
used to later access or remove the values. Insertion, removal and access all
take O(1) time with low overhead. Great for storing collections of objects
that need stable, safe references but have no clear ownership otherwise,
such as game entities or graph nodes.</p>
<p>The difference between a <a href="https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html"><code>BTreeMap</code></a> or <a href="https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html"><code>HashMap</code></a> and a slot map is
that the slot map generates and returns the key when inserting a value. A
key is always unique and will only refer to the value that was inserted.
A slot map’s main purpose is to simply own things in a safe and efficient
manner.</p>
<p>You can also create (multiple) secondary maps that can map the keys returned
by <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> to other values, to associate arbitrary data with objects
stored in slot maps, without hashing required - it’s direct indexing under
the hood.</p>
<p>The minimum required stable Rust version for this crate is 1.49.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>sm = SlotMap::new();
<span class="kw">let </span>foo = sm.insert(<span class="string">&quot;foo&quot;</span>);  <span class="comment">// Key generated on insert.
</span><span class="kw">let </span>bar = sm.insert(<span class="string">&quot;bar&quot;</span>);
<span class="macro">assert_eq!</span>(sm[foo], <span class="string">&quot;foo&quot;</span>);
<span class="macro">assert_eq!</span>(sm[bar], <span class="string">&quot;bar&quot;</span>);

sm.remove(bar);
<span class="kw">let </span>reuse = sm.insert(<span class="string">&quot;reuse&quot;</span>);  <span class="comment">// Space from bar reused.
</span><span class="macro">assert_eq!</span>(sm.contains_key(bar), <span class="bool-val">false</span>);  <span class="comment">// After deletion a key stays invalid.

</span><span class="kw">let </span><span class="kw-2">mut </span>sec = SecondaryMap::new();
sec.insert(foo, <span class="string">&quot;noun&quot;</span>);  <span class="comment">// We provide the key for secondary maps.
</span>sec.insert(reuse, <span class="string">&quot;verb&quot;</span>);

<span class="kw">for </span>(key, val) <span class="kw">in </span>sm {
    <span class="macro">println!</span>(<span class="string">&quot;{} is a {}&quot;</span>, val, sec[key]);
}</code></pre></div>
<h2 id="serialization-through-serde-no_std-support-and-unstable-features"><a href="#serialization-through-serde-no_std-support-and-unstable-features">Serialization through <code>serde</code>, <code>no_std</code> support and unstable features</a></h2>
<p>Both keys and the slot maps have full (de)seralization support through
the <a href="https://github.com/serde-rs/serde"><code>serde</code></a> library. A key remains valid for a slot map even after one or
both have been serialized and deserialized! This makes storing or
transferring complicated referential structures and graphs a breeze. Care has
been taken such that deserializing keys and slot maps from untrusted sources
is safe. If you wish to use these features you must enable the <code>serde</code>
feature flag for <code>slotmap</code> in your <code>Cargo.toml</code>.</p>
<div class="example-wrap"><pre class="language-text"><code>slotmap = { version = &quot;1.0&quot;, features = [&quot;serde&quot;] }</code></pre></div>
<p>This crate also supports <a href="https://doc.rust-lang.org/1.7.0/book/no-stdlib.html"><code>no_std</code></a> environments, but does require the
<a href="https://doc.rust-lang.org/nightly/alloc/index.html" title="alloc"><code>alloc</code></a> crate to be available. To enable this you have to disable the
<code>std</code> feature that is enabled by default:</p>
<div class="example-wrap"><pre class="language-text"><code>slotmap = { version = &quot;1.0&quot;, default-features = false }</code></pre></div>
<p>Unfortunately <a href="struct.SparseSecondaryMap.html" title="SparseSecondaryMap"><code>SparseSecondaryMap</code></a> is not available in <a href="https://doc.rust-lang.org/1.7.0/book/no-stdlib.html"><code>no_std</code></a>, because
it relies on <a href="https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html"><code>HashMap</code></a>. Finally the <code>unstable</code> feature can be defined to
enable the parts of <code>slotmap</code> that only work on nightly Rust.</p>
<h2 id="why-not-index-a-vec-or-use-slab-stable-vec-etc"><a href="#why-not-index-a-vec-or-use-slab-stable-vec-etc">Why not index a <code>Vec</code>, or use <code>slab</code>, <code>stable-vec</code>, etc?</a></h2>
<p>Those solutions either can not reclaim memory from deleted elements or
suffer from the ABA problem. The keys returned by <code>slotmap</code> are versioned.
This means that once a key is removed, it stays removed, even if the
physical storage inside the slotmap is reused for new elements. The key is a
permanently unique<sup>*</sup> reference to the inserted value. Despite
supporting versioning, a <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> is often not (much) slower than the
alternative, by internally using carefully checked unsafe code. Finally,
<code>slotmap</code> simply has a lot of features that make your life easy.</p>
<h2 id="performance-characteristics-and-implementation-details"><a href="#performance-characteristics-and-implementation-details">Performance characteristics and implementation details</a></h2>
<p>Insertion, access and deletion is all O(1) with low overhead by storing the
elements inside a <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>Vec</code></a>. Unlike references or indices into a vector,
unless you remove a key it is never invalidated. Behind the scenes each
slot in the vector is a <code>(value, version)</code> tuple. After insertion the
returned key also contains a version. Only when the stored version and
version in a key match is a key valid. This allows us to reuse space in the
vector after deletion without letting removed keys point to spurious new
elements. <sup>*</sup>After 2<sup>31</sup> deletions and insertions to the
same underlying slot the version wraps around and such a spurious reference
could potentially occur. It is incredibly unlikely however, and in all
circumstances is the behavior safe. A slot map can hold up to
2<sup>32</sup> - 2 elements at a time.</p>
<p>The memory usage for each slot in <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> is <code>4 + max(sizeof(T), 4)</code>
rounded up to the alignment of <code>T</code>. Similarly it is <code>4 + max(sizeof(T), 12)</code>
for <a href="struct.HopSlotMap.html" title="HopSlotMap"><code>HopSlotMap</code></a>. <a href="struct.DenseSlotMap.html" title="DenseSlotMap"><code>DenseSlotMap</code></a> has an overhead of 8 bytes per element
and 8 bytes per slot.</p>
<h2 id="choosing-slotmap-hopslotmap-or-denseslotmap"><a href="#choosing-slotmap-hopslotmap-or-denseslotmap">Choosing <code>SlotMap</code>, <code>HopSlotMap</code> or <code>DenseSlotMap</code></a></h2>
<p>A <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> is the fastest for most operations, except iteration. It can
never shrink the size of its underlying storage, because it must remember
for each storage slot what the latest stored version was, even if the slot
is empty now. This means that iteration can be slow as it must iterate over
potentially a lot of empty slots.</p>
<p><a href="struct.HopSlotMap.html" title="HopSlotMap"><code>HopSlotMap</code></a> solves this by maintaining more information on
insertion/removal, allowing it to iterate only over filled slots by ‘hopping
over’ contiguous blocks of vacant slots. This can give it significantly
better iteration speed.  If you expect to iterate over all elements in a
<a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> a lot, and potentially have a lot of deleted elements, choose
<a href="struct.HopSlotMap.html" title="HopSlotMap"><code>HopSlotMap</code></a>. The downside is that insertion and removal is roughly twice
as slow. Random access is the same speed for both.</p>
<p><a href="struct.DenseSlotMap.html" title="DenseSlotMap"><code>DenseSlotMap</code></a> goes even further and stores all elements on a contiguous
block of memory. It uses two indirections per random access; the slots
contain indices used to access the contiguous memory. This means random
access is slower than both <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> and <a href="struct.HopSlotMap.html" title="HopSlotMap"><code>HopSlotMap</code></a>, but iteration is
significantly faster, as fast as a normal <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>Vec</code></a>.</p>
<h2 id="choosing-secondarymap-or-sparsesecondarymap"><a href="#choosing-secondarymap-or-sparsesecondarymap">Choosing <code>SecondaryMap</code> or <code>SparseSecondaryMap</code></a></h2>
<p>You want to associate extra data with objects stored in a slot map, so you
use (multiple) secondary maps to map keys to that data.</p>
<p>A <a href="struct.SecondaryMap.html" title="SecondaryMap"><code>SecondaryMap</code></a> is simply a <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html"><code>Vec</code></a> of slots like slot map is, and
essentially provides all the same guarantees as <a href="struct.SlotMap.html" title="SlotMap"><code>SlotMap</code></a> does for its
operations (with the exception that you provide the keys as produced by the
primary slot map). This does mean that even if you associate data to only
a single element from the primary slot map, you could need and have to
initialize as much memory as the original.</p>
<p>A <a href="struct.SparseSecondaryMap.html" title="SparseSecondaryMap"><code>SparseSecondaryMap</code></a> is like a <a href="https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html"><code>HashMap</code></a> from keys to objects, however
it automatically removes outdated keys for slots that had their space
reused. You should use this variant if you expect to store some associated
data for only a small portion of the primary slot map.</p>
<h2 id="custom-key-types"><a href="#custom-key-types">Custom key types</a></h2>
<p>If you have multiple slot maps it’s an error to use the key of one slot map
on another slot map. The result is safe, but unspecified, and can not be
detected at runtime, so it can lead to a hard to find bug.</p>
<p>To prevent this, slot maps allow you to specify what the type is of the key
they return. You can construct new key types using the <a href="macro.new_key_type.html" title="new_key_type!"><code>new_key_type!</code></a>
macro. The resulting type behaves exactly like <a href="struct.DefaultKey.html" title="DefaultKey"><code>DefaultKey</code></a>, but is a
distinct type. So instead of simply using <code>SlotMap&lt;DefaultKey, Player&gt;</code> you
would use:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">new_key_type! </span>{ <span class="kw">struct </span>PlayerKey; }
<span class="kw">let </span>sm: SlotMap&lt;PlayerKey, Player&gt; = SlotMap::with_key();</code></pre></div>
<p>You can write code generic over any key type using the <a href="trait.Key.html" title="Key"><code>Key</code></a> trait.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="basic/index.html" title="slotmap::basic mod">basic</a></div><div class="item-right docblock-short">Contains the slot map implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="dense/index.html" title="slotmap::dense mod">dense</a></div><div class="item-right docblock-short">Contains the dense slot map implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="hop/index.html" title="slotmap::hop mod">hop</a></div><div class="item-right docblock-short">Contains the faster iteration, slower insertion/removal slot map
implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="secondary/index.html" title="slotmap::secondary mod">secondary</a></div><div class="item-right docblock-short">Contains the secondary map implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="sparse_secondary/index.html" title="slotmap::sparse_secondary mod">sparse_secondary</a></div><div class="item-right docblock-short">Contains the sparse secondary map implementation.</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.new_key_type.html" title="slotmap::new_key_type macro">new_key_type</a></div><div class="item-right docblock-short">A helper macro to create new key types. If you use a new key type for each
slot map you create you can entirely prevent using the wrong key on the
wrong slot map.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DefaultKey.html" title="slotmap::DefaultKey struct">DefaultKey</a></div><div class="item-right docblock-short">The default slot map key type.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DenseSlotMap.html" title="slotmap::DenseSlotMap struct">DenseSlotMap</a></div><div class="item-right docblock-short">Dense slot map, storage with stable unique keys.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HopSlotMap.html" title="slotmap::HopSlotMap struct">HopSlotMap</a></div><div class="item-right docblock-short">Hop slot map, storage with stable unique keys.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeyData.html" title="slotmap::KeyData struct">KeyData</a></div><div class="item-right docblock-short">The actual data stored in a <a href="trait.Key.html" title="Key"><code>Key</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SecondaryMap.html" title="slotmap::SecondaryMap struct">SecondaryMap</a></div><div class="item-right docblock-short">Secondary map, associate data with previously stored elements in a slot map.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SlotMap.html" title="slotmap::SlotMap struct">SlotMap</a></div><div class="item-right docblock-short">Slot map, storage with stable unique keys.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SparseSecondaryMap.html" title="slotmap::SparseSecondaryMap struct">SparseSecondaryMap</a></div><div class="item-right docblock-short">Sparse secondary map, associate data with previously stored elements in a
slot map.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Key.html" title="slotmap::Key trait">Key</a></div><div class="item-right docblock-short">Key used to access stored values in a slot map.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="slotmap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (234151769 2022-12-03)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>