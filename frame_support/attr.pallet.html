<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`pallet` attribute macro allows to define a pallet to be used in `construct_runtime!`."><meta name="keywords" content="rust, rustlang, rust-lang, pallet"><title>pallet in frame_support - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e963ab4a0d0c903e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-046227e470cd3629.css"><link rel="stylesheet" disabled href="../static.files/dark-800f2ee593c8e6f7.css"><link rel="stylesheet" disabled href="../static.files/ayu-9edae3c387f5a5b3.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-287cecec4dbb45b0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../frame_support/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../frame_support/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In frame_support</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Attribute Macro <a href="index.html">frame_support</a>::<wbr><a class="attr" href="#">pallet</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/frame_support_procedural/lib.rs.html#407">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust attr"><code>#[pallet]</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>pallet</code> attribute macro allows to define a pallet to be used in <code>construct_runtime!</code>.</p>
<p>It is define by a module item:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet]
</span><span class="kw">pub mod </span>pallet {
...
}</code></pre></div>
<p>Inside the module the macro will parse item with the attribute: <code>#[pallet::*]</code>, some
attributes are mandatory, some other optional.</p>
<p>The attribute are explained with the syntax of non instantiable pallets, to see how pallet
with instance work see below example.</p>
<p>Note various type can be automatically imported using pallet_prelude in frame_support and
frame_system:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet]
</span><span class="kw">pub mod </span>pallet {
		<span class="kw">use </span>frame_support::pallet_prelude::<span class="kw-2">*</span>;
		<span class="kw">use </span>frame_system::pallet_prelude::<span class="kw-2">*</span>;
		...
}</code></pre></div>
<h2 id="config-trait-palletconfig-mandatory"><a href="#config-trait-palletconfig-mandatory">Config trait: <code>#[pallet::config]</code> mandatory</a></h2>
<p>The trait defining generics of the pallet.</p>
<p>Item must be defined as</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::config]
</span><span class="kw">pub trait </span>Config: frame_system::Config + <span class="macro-nonterminal">$optionally_some_other_supertraits
$optional_where_clause
</span>{
...
}</code></pre></div>
<p>I.e. a regular trait definition named <code>Config</code>, with supertrait <code>frame_system::Config</code>,
optionally other supertrait and where clause.</p>
<p>The associated type <code>Event</code> is reserved, if defined it must bounds <code>From&lt;Event&gt;</code> and
<code>IsType&lt;&lt;Self as frame_system::Config&gt;::Event&gt;</code>, see <code>#[pallet::event]</code> for more
information.</p>
<p>To put <code>Get</code> associated type into metadatas, use the attribute <code>#[pallet::constant]</code>, e.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::config]
</span><span class="kw">pub trait </span>Config: frame_system::Config {
		<span class="attr">#[pallet::constant]
		</span><span class="kw">type </span>Foo: Get&lt;u32&gt;;
}</code></pre></div>
<p>To bypass the <code>frame_system::Config</code> supertrait check, use the attribute
<code>#[pallet::disable_frame_system_supertrait_check]</code>, e.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::config]
#[pallet::disable_frame_system_supertrait_check]
</span><span class="kw">pub trait </span>Config: pallet_timestamp::Config {}</code></pre></div>
<h4 id="macro-expansion"><a href="#macro-expansion">Macro expansion:</a></h4>
<p>The macro expand pallet constant metadata with the information given by
<code>#[pallet::constant]</code>.</p>
<h2 id="pallet-struct-placeholder-palletpallet-mandatory"><a href="#pallet-struct-placeholder-palletpallet-mandatory">Pallet struct placeholder: <code>#[pallet::pallet]</code> mandatory</a></h2>
<p>The placeholder struct, on which is implemented pallet informations.</p>
<p>Item must be defined as followed:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::pallet]
</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);</code></pre></div>
<p>I.e. a regular struct definition named <code>Pallet</code>, with generic T and no where clause.</p>
<p>To generate a <code>Store</code> trait associating all storages, use the attribute
<code>#[pallet::generate_store($vis trait Store)]</code>, e.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::pallet]
#[pallet::generate_store(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait </span>Store)]
</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);</code></pre></div>
<p>More precisely the store trait contains an associated type for each storage. It is
implemented for <code>Pallet</code> allowing to access the storage from pallet struct.</p>
<p>Thus when defining a storage named <code>Foo</code>, it can later be accessed from <code>Pallet</code> using
<code>&lt;Pallet as Store&gt;::Foo</code>.</p>
<p>To generate the full storage info (used for PoV calculation) use the attribute
<code>#[pallet::generate_storage_info]</code>, e.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::pallet]
#[pallet::generate_storage_info]
</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);</code></pre></div>
<p>This require all storage to implement the trait <a href="traits/trait.StorageInfoTrait.html" title="traits::StorageInfoTrait"><code>traits::StorageInfoTrait</code></a>, thus all keys
and value types must bound <a href="pallet_prelude/trait.MaxEncodedLen.html" title="pallet_prelude::MaxEncodedLen"><code>pallet_prelude::MaxEncodedLen</code></a>.
Some individual storage can opt-out from this constraint by using <code>#[pallet::unbounded]</code>,
see <code>#[pallet::storage]</code> documentation.</p>
<p>As the macro implements <a href="dispatch/trait.GetStorageVersion.html" title="traits::GetStorageVersion"><code>traits::GetStorageVersion</code></a>, the current storage version needs to
be communicated to the macro. This can be done by using the <code>storage_version</code> attribute:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">const </span>STORAGE_VERSION: StorageVersion = StorageVersion::new(<span class="number">5</span>);

<span class="attr">#[pallet::pallet]
#[pallet::storage_version(STORAGE_VERSION)]
</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);</code></pre></div>
<p>If not present, the current storage version is set to the default value.</p>
<h4 id="macro-expansion-1"><a href="#macro-expansion-1">Macro expansion:</a></h4>
<p>The macro add this attribute to the struct definition:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(
	frame_support::CloneNoBound,
	frame_support::EqNoBound,
	frame_support::PartialEqNoBound,
	frame_support::RuntimeDebugNoBound,
)]</span></code></pre></div>
<p>and replace the type <code>_</code> by <code>PhantomData&lt;T&gt;</code>.</p>
<p>It implements on pallet:</p>
<ul>
<li><a href="dispatch/trait.GetStorageVersion.html" title="traits::GetStorageVersion"><code>traits::GetStorageVersion</code></a></li>
<li><a href="traits/trait.OnGenesis.html" title="traits::OnGenesis"><code>traits::OnGenesis</code></a>: contains some logic to write pallet version into storage.</li>
<li><code>PalletErrorTypeInfo</code>: provides the type information for the pallet error, if defined.</li>
</ul>
<p>It declares <code>type Module</code> type alias for <code>Pallet</code>, used by <a href="macro.construct_runtime.html" title="construct_runtime"><code>construct_runtime</code></a>.</p>
<p>It implements <a href="traits/trait.PalletInfoAccess.html" title="traits::PalletInfoAccess"><code>traits::PalletInfoAccess</code></a> on <code>Pallet</code> to ease access to pallet
informations given by <a href="traits/trait.PalletInfo.html" title="frame_support::traits::PalletInfo"><code>frame_support::traits::PalletInfo</code></a>.
(The implementation uses the associated type <code>frame_system::Config::PalletInfo</code>).</p>
<p>It implements <a href="traits/trait.StorageInfoTrait.html" title="traits::StorageInfoTrait"><code>traits::StorageInfoTrait</code></a> on <code>Pallet</code> which give information about all
storages.</p>
<p>If the attribute generate_store is set then the macro creates the trait <code>Store</code> and
implements it on <code>Pallet</code>.</p>
<p>If the attribute set_storage_max_encoded_len is set then the macro call
<a href="traits/trait.StorageInfoTrait.html" title="traits::StorageInfoTrait"><code>traits::StorageInfoTrait</code></a> for each storage in the implementation of
<a href="traits/trait.StorageInfoTrait.html" title="traits::StorageInfoTrait"><code>traits::StorageInfoTrait</code></a> for the pallet.
Otherwise it implements <a href="traits/trait.StorageInfoTrait.html" title="traits::StorageInfoTrait"><code>traits::StorageInfoTrait</code></a> for the pallet using the
<a href="traits/trait.PartialStorageInfoTrait.html" title="traits::PartialStorageInfoTrait"><code>traits::PartialStorageInfoTrait</code></a> implementation of storages.</p>
<h2 id="hooks-pallethooks-optional"><a href="#hooks-pallethooks-optional">Hooks: <code>#[pallet::hooks]</code> optional</a></h2>
<p>Implementation of <code>Hooks</code> on <code>Pallet</code> allowing to define some specific pallet logic.</p>
<p>Item must be defined as</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::hooks]
</span><span class="kw">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="kw">for </span>Pallet&lt;T&gt; <span class="macro-nonterminal">$optional_where_clause </span>{
}</code></pre></div>
<p>I.e. a regular trait implementation with generic bound: <code>T: Config</code>, for the trait
<code>Hooks&lt;BlockNumberFor&lt;T&gt;&gt;</code> (they are defined in preludes), for the type <code>Pallet&lt;T&gt;</code>
and with an optional where clause.</p>
<p>If no <code>#[pallet::hooks]</code> exists, then a default implementation corresponding to the
following code is automatically generated:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::hooks]
</span><span class="kw">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="kw">for </span>Pallet&lt;T&gt; {}</code></pre></div>
<h4 id="macro-expansion-2"><a href="#macro-expansion-2">Macro expansion:</a></h4>
<p>The macro implements the traits <code>OnInitialize</code>, <code>OnIdle</code>, <code>OnFinalize</code>, <code>OnRuntimeUpgrade</code>,
<code>OffchainWorker</code>, <code>IntegrityTest</code> using <code>Hooks</code> implementation.</p>
<p>NOTE: OnRuntimeUpgrade is implemented with <code>Hooks::on_runtime_upgrade</code> and some additional
logic. E.g. logic to write pallet version into storage.</p>
<p>NOTE: The macro also adds some tracing logic when implementing the above traits. The
following  hooks emit traces: <code>on_initialize</code>, <code>on_finalize</code> and <code>on_runtime_upgrade</code>.</p>
<h2 id="call-palletcall-optional"><a href="#call-palletcall-optional">Call: <code>#[pallet::call]</code> optional</a></h2>
<p>Implementation of pallet dispatchables.</p>
<p>Item must be defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::call]
</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
	<span class="doccomment">/// $some_doc
	</span><span class="attr">#[pallet::weight(<span class="macro-nonterminal">$ExpressionResultingInWeight</span>)]
	</span><span class="kw">pub fn </span><span class="macro-nonterminal">$fn_name</span>(
		origin: OriginFor&lt;T&gt;,
		<span class="macro-nonterminal">$some_arg</span>: <span class="macro-nonterminal">$some_type</span>,
		<span class="comment">// or with compact attribute: #[pallet::compact] $some_arg: $some_type,
		</span>...
	) -&gt; DispatchResultWithPostInfo { <span class="comment">// or `-&gt; DispatchResult`
		</span>...
	}
	...
}</code></pre></div>
<p>I.e. a regular type implementation, with generic <code>T: Config</code>, on type <code>Pallet&lt;T&gt;</code>, with
optional where clause.</p>
<p>Each dispatchable needs to define a weight with <code>#[pallet::weight($expr)]</code> attribute,
the first argument must be <code>origin: OriginFor&lt;T&gt;</code>, compact encoding for argument can be
used using <code>#[pallet::compact]</code>, function must return <code>DispatchResultWithPostInfo</code> or
<code>DispatchResult</code>.</p>
<p>Each dispatchable may also be annotated with the <code>#[pallet::call_index($idx)]</code> attribute,
which defines and sets the codec index for the dispatchable function in the <code>Call</code> enum.</p>
<p>All call indexes start from 0, until it encounters a dispatchable function with a defined
call index. The dispatchable function that lexically follows the function with a defined
call index will have that call index, but incremented by 1, e.g. if there are 3
dispatchable functions <code>fn foo</code>, <code>fn bar</code> and <code>fn qux</code> in that order, and only <code>fn bar</code> has
a call index of 10, then <code>fn qux</code> will have an index of 11, instead of 1.</p>
<p>All arguments must implement <code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Decode</code>, <code>Encode</code>, <code>Clone</code>. For
ease of use, bound the trait <code>Member</code> available in frame_support::pallet_prelude.</p>
<p>If no <code>#[pallet::call]</code> exists, then a default implementation corresponding to the
following code is automatically generated:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::call]
</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {}</code></pre></div>
<p><strong>WARNING</strong>: modifying dispatchables, changing their order, removing some must be done with
care. Indeed this will change the outer runtime call type (which is an enum with one
variant per pallet), this outer runtime call can be stored on-chain (e.g. in
pallet-scheduler). Thus migration might be needed. To mitigate against some of this, the
<code>#[pallet::call_index($idx)]</code> attribute can be used to fix the order of the dispatchable so
that the <code>Call</code> enum encoding does not change after modification.</p>
<h4 id="macro-expansion-3"><a href="#macro-expansion-3">Macro expansion</a></h4>
<p>The macro creates an enum <code>Call</code> with one variant per dispatchable. This enum implements:
<code>Clone</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Debug</code> (with stripped implementation in <code>not(&quot;std&quot;)</code>),
<code>Encode</code>, <code>Decode</code>, <code>GetDispatchInfo</code>, <code>GetCallName</code>, <code>UnfilteredDispatchable</code>.</p>
<p>The macro implement the <code>Callable</code> trait on <code>Pallet</code> and a function <code>call_functions</code> which
returns the dispatchable metadata.</p>
<h2 id="extra-constants-palletextra_constants-optional"><a href="#extra-constants-palletextra_constants-optional">Extra constants: <code>#[pallet::extra_constants]</code> optional</a></h2>
<p>Allow to define some extra constants to put into constant metadata.</p>
<p>Item must be defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::extra_constants]
</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; <span class="kw">where </span><span class="macro-nonterminal">$optional_where_clause </span>{
	<span class="doccomment">/// $some_doc
	</span><span class="macro-nonterminal">$vis </span><span class="kw">fn </span><span class="macro-nonterminal">$fn_name</span>() -&gt; <span class="macro-nonterminal">$some_return_type </span>{
		...
	}
	...
}</code></pre></div>
<p>I.e. a regular rust implement block with some optional where clause and functions with 0
args, 0 generics, and some return type.</p>
<h4 id="macro-expansion-4"><a href="#macro-expansion-4">Macro expansion</a></h4>
<p>The macro add some extra constant to pallet constant metadata.</p>
<h2 id="error-palleterror-optional"><a href="#error-palleterror-optional">Error: <code>#[pallet::error]</code> optional</a></h2>
<p>Allow to define an error type to be return from dispatchable on error.
This error type informations are put into metadata.</p>
<p>Item must be defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::error]
</span><span class="kw">pub enum </span>Error&lt;T&gt; {
	<span class="doccomment">/// $some_optional_doc
	</span><span class="macro-nonterminal">$SomeFieldLessVariant</span>,
	<span class="doccomment">/// $some_more_optional_doc
	</span><span class="macro-nonterminal">$SomeVariantWithOneField</span>(FieldType),
	...
}</code></pre></div>
<p>I.e. a regular rust enum named <code>Error</code>, with generic <code>T</code> and fieldless or multiple-field
variants.</p>
<p>Any field type in the enum variants must implement <a href="pallet_prelude/trait.TypeInfo.html" title="scale_info::TypeInfo"><code>scale_info::TypeInfo</code></a> in order to be
properly used in the metadata, and its encoded size should be as small as possible,
preferably 1 byte in size in order to reduce storage size. The error enum itself has an
absolute maximum encoded size specified by <a href="constant.MAX_MODULE_ERROR_ENCODED_SIZE.html" title="MAX_MODULE_ERROR_ENCODED_SIZE"><code>MAX_MODULE_ERROR_ENCODED_SIZE</code></a>.</p>
<p>Field types in enum variants must also implement <a href="traits/trait.PalletError.html"><code>PalletError</code></a>,
otherwise the pallet will fail to compile. Rust primitive types have already implemented
the <a href="traits/trait.PalletError.html"><code>PalletError</code></a> trait along with some commonly used stdlib types
such as <code>Option</code> and <code>PhantomData</code>, and hence in most use cases, a manual implementation is
not necessary and is discouraged.</p>
<p>The generic <code>T</code> mustn’t bound anything and where clause is not allowed. But bounds and
where clause shouldn’t be needed for any usecase.</p>
<h4 id="macro-expansion-5"><a href="#macro-expansion-5">Macro expansion</a></h4>
<p>The macro implements <code>Debug</code> trait and functions <code>as_u8</code> using variant position, and
<code>as_str</code> using variant doc.</p>
<p>The macro implements <code>From&lt;Error&lt;T&gt;&gt;</code> for <code>&amp;'static str</code>.
The macro implements <code>From&lt;Error&lt;T&gt;&gt;</code> for <code>DispatchError</code>.</p>
<h2 id="event-palletevent-optional"><a href="#event-palletevent-optional">Event: <code>#[pallet::event]</code> optional</a></h2>
<p>Allow to define pallet events, pallet events are stored in the block when they deposited
(and removed in next block).</p>
<p>Item is defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::event]
#[pallet::generate_deposit(<span class="macro-nonterminal">$visibility </span><span class="kw">fn </span>deposit_event)] </span><span class="comment">// Optional
</span><span class="kw">pub enum </span>Event&lt;<span class="macro-nonterminal">$some_generic</span>&gt; <span class="macro-nonterminal">$optional_where_clause </span>{
	<span class="doccomment">/// Some doc
	</span><span class="macro-nonterminal">$SomeName</span>(<span class="macro-nonterminal">$SomeType</span>, <span class="macro-nonterminal">$YetanotherType</span>, ...),
	...
}</code></pre></div>
<p>I.e. an enum (with named or unnamed fields variant), named Event, with generic: none or <code>T</code>
or <code>T: Config</code>, and optional where clause.</p>
<p>Each field must implement <code>Clone</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Encode</code>, <code>Decode</code>, and <code>Debug</code> (on
std only).
For ease of use, bound the trait <code>Member</code> available in frame_support::pallet_prelude.</p>
<p>The attribute <code>#[pallet::generate_deposit($visibility fn deposit_event)]</code> generate a helper
function on <code>Pallet</code> to deposit event.</p>
<p>NOTE: For instantiable pallet, event must be generic over T and I.</p>
<h4 id="macro-expansion-6"><a href="#macro-expansion-6">Macro expansion:</a></h4>
<p>Macro will add on enum <code>Event</code> the attributes:</p>
<ul>
<li><code>#[derive(frame_support::CloneNoBound)]</code>,</li>
<li><code>#[derive(frame_support::EqNoBound)]</code>,</li>
<li><code>#[derive(frame_support::PartialEqNoBound)]</code>,</li>
<li><code>#[derive(codec::Encode)]</code>,</li>
<li><code>#[derive(codec::Decode)]</code>,</li>
<li><code>#[derive(frame_support::RuntimeDebugNoBound)]</code></li>
</ul>
<p>Macro implements <code>From&lt;Event&lt;..&gt;&gt;</code> for ().</p>
<p>Macro implements metadata function on <code>Event</code> returning the <code>EventMetadata</code>.</p>
<p>If <code>#[pallet::generate_deposit]</code> then macro implement <code>fn deposit_event</code> on <code>Pallet</code>.</p>
<h2 id="storage-palletstorage-optional"><a href="#storage-palletstorage-optional">Storage: <code>#[pallet::storage]</code> optional</a></h2>
<p>Allow to define some abstract storage inside runtime storage and also set its metadata.
This attribute can be used multiple times.</p>
<p>Item is defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
#[pallet::getter(<span class="kw">fn </span><span class="macro-nonterminal">$getter_name</span>)] </span><span class="comment">// optional
</span><span class="macro-nonterminal">$vis </span><span class="kw">type </span><span class="macro-nonterminal">$StorageName</span>&lt;<span class="macro-nonterminal">$some_generic</span>&gt; <span class="macro-nonterminal">$optional_where_clause
	</span>= <span class="macro-nonterminal">$StorageType</span>&lt;<span class="macro-nonterminal">$generic_name </span>= <span class="macro-nonterminal">$some_generics</span>, <span class="macro-nonterminal">$other_name </span>= <span class="macro-nonterminal">$some_other</span>, ...&gt;;</code></pre></div>
<p>or with unnamed generic</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
#[pallet::getter(<span class="kw">fn </span><span class="macro-nonterminal">$getter_name</span>)] </span><span class="comment">// optional
</span><span class="macro-nonterminal">$vis </span><span class="kw">type </span><span class="macro-nonterminal">$StorageName</span>&lt;<span class="macro-nonterminal">$some_generic</span>&gt; <span class="macro-nonterminal">$optional_where_clause
	</span>= <span class="macro-nonterminal">$StorageType</span>&lt;<span class="kw">_</span>, <span class="macro-nonterminal">$some_generics</span>, ...&gt;;</code></pre></div>
<p>I.e. it must be a type alias, with generics: <code>T</code> or <code>T: Config</code>, aliased type must be one
of <code>StorageValue</code>, <code>StorageMap</code> or <code>StorageDoubleMap</code> (defined in frame_support).
The generic arguments of the storage type can be given in two manner: named and unnamed.
For named generic argument: the name for each argument is the one as define on the storage
struct:</p>
<ul>
<li><a href="storage/types/struct.StorageValue.html" title="pallet_prelude::StorageValue"><code>pallet_prelude::StorageValue</code></a> expect <code>Value</code> and optionally <code>QueryKind</code> and <code>OnEmpty</code>,</li>
<li><a href="storage/types/struct.StorageMap.html" title="pallet_prelude::StorageMap"><code>pallet_prelude::StorageMap</code></a> expect <code>Hasher</code>, <code>Key</code>, <code>Value</code> and optionally <code>QueryKind</code>
and <code>OnEmpty</code>,</li>
<li><a href="storage/types/struct.CountedStorageMap.html" title="pallet_prelude::CountedStorageMap"><code>pallet_prelude::CountedStorageMap</code></a> expect <code>Hasher</code>, <code>Key</code>, <code>Value</code> and optionally
<code>QueryKind</code> and <code>OnEmpty</code>,</li>
<li><a href="storage/types/struct.StorageDoubleMap.html" title="pallet_prelude::StorageDoubleMap"><code>pallet_prelude::StorageDoubleMap</code></a> expect <code>Hasher1</code>, <code>Key1</code>, <code>Hasher2</code>, <code>Key2</code>, <code>Value</code>
and optionally <code>QueryKind</code> and <code>OnEmpty</code>.</li>
</ul>
<p>For unnamed generic argument: Their first generic must be <code>_</code> as it is replaced by the
macro and other generic must declared as a normal declaration of type generic in rust.</p>
<p>The Prefix generic written by the macro is generated using
<code>PalletInfo::name::&lt;Pallet&lt;..&gt;&gt;()</code> and the name of the storage type.
E.g. if runtime names the pallet “MyExample” then the storage <code>type Foo&lt;T&gt; = ...</code> use the
prefix: <code>Twox128(b&quot;MyExample&quot;) ++ Twox128(b&quot;Foo&quot;)</code>.</p>
<p>For the <code>CountedStorageMap</code> variant, the Prefix also implements
<code>CountedStorageMapInstance</code>. It associate a <code>CounterPrefix</code>, which is implemented same as
above, but the storage prefix is prepend with <code>&quot;CounterFor&quot;</code>.
E.g. if runtime names the pallet “MyExample” then the storage
<code>type Foo&lt;T&gt; = CountedStorageaMap&lt;...&gt;</code> will store its counter at the prefix:
<code>Twox128(b&quot;MyExample&quot;) ++ Twox128(b&quot;CounterForFoo&quot;)</code>.</p>
<p>E.g:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; = StorageMap&lt;Hasher = Blake2_128Concat, Key = u32, Value = u32&gt;;</code></pre></div>
<p>In this case the final prefix used by the map is
<code>Twox128(b&quot;MyExample&quot;) ++ Twox128(b&quot;OtherName&quot;)</code>.</p>
<p>The optional attribute <code>#[pallet::getter(fn $my_getter_fn_name)]</code> allows to define a
getter function on <code>Pallet</code>.</p>
<p>The optional attribute <code>#[pallet::storage_prefix = &quot;SomeName&quot;]</code> allow to define the storage
prefix to use, see how <code>Prefix</code> generic is implemented above.</p>
<p>E.g:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
#[pallet::storage_prefix = <span class="string">&quot;foo&quot;</span>]
#[pallet::getter(<span class="kw">fn </span>my_storage)]
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; = StorageMap&lt;Hasher = Blake2_128Concat, Key = u32, Value = u32&gt;;</code></pre></div>
<p>or</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
#[pallet::getter(<span class="kw">fn </span>my_storage)]
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; = StorageMap&lt;<span class="kw">_</span>, Blake2_128Concat, u32, u32&gt;;</code></pre></div>
<p>The optional attribute <code>#[pallet::unbounded]</code> allows to declare the storage as unbounded.
When implementating the storage info (when <code>#[pallet::generate_storage_info]</code> is specified
on the pallet struct placeholder), the size of the storage will be declared as unbounded.
This can be useful for storage which can never go into PoV (Proof of Validity).</p>
<p>The optional attributes <code>#[cfg(..)]</code> allow conditional compilation for the storage.</p>
<p>E.g:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">&quot;my-feature&quot;</span>)]
#[pallet::storage]
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; = StorageValue&lt;Value = u32&gt;;</code></pre></div>
<p>All the <code>cfg</code> attributes are automatically copied to the items generated for the storage,
i.e. the getter, storage prefix, and the metadata element etc.</p>
<p>Any type placed as the <code>QueryKind</code> parameter must implement
<a href="storage/types/trait.QueryKindTrait.html" title="frame_support::storage::types::QueryKindTrait"><code>frame_support::storage::types::QueryKindTrait</code></a>. There are 3 implementations of this
trait by default:</p>
<ol>
<li><a href="storage/types/struct.OptionQuery.html" title="frame_support::storage::types::OptionQuery"><code>frame_support::storage::types::OptionQuery</code></a>, the default <code>QueryKind</code> used when this
type parameter is omitted. Specifying this as the <code>QueryKind</code> would cause storage map
APIs that return a <code>QueryKind</code> to instead return an <code>Option</code>, returning <code>Some</code> when a
value does exist under a specified storage key, and <code>None</code> otherwise.</li>
<li><a href="storage/types/struct.ValueQuery.html" title="frame_support::storage::types::ValueQuery"><code>frame_support::storage::types::ValueQuery</code></a> causes storage map APIs that return a
<code>QueryKind</code> to instead return the value type. In cases where a value does not exist
under a specified storage key, the <code>OnEmpty</code> type parameter on <code>QueryKindTrait</code> is used
to return an appropriate value.</li>
<li><a href="storage/types/struct.ResultQuery.html" title="frame_support::storage::types::ResultQuery"><code>frame_support::storage::types::ResultQuery</code></a> causes storage map APIs that return a
<code>QueryKind</code> to instead return a <code>Result&lt;T, E&gt;</code>, with <code>T</code> being the value type and <code>E</code>
being the pallet error type specified by the <code>#[pallet::error]</code> attribute. In cases
where a value does not exist under a specified storage key, an <code>Err</code> with the specified
pallet error variant is returned.</li>
</ol>
<p>NOTE: If the <code>QueryKind</code> generic parameter is still generic at this stage or is using some
type alias then the generation of the getter might fail. In this case the getter can be
implemented manually.</p>
<p>NOTE: The generic <code>Hasher</code> must implement the <a href="trait.StorageHasher.html" title="StorageHasher"><code>StorageHasher</code></a> trait (or the type is not
usable at all). We use <a href="trait.StorageHasher.html#associatedconstant.METADATA" title="StorageHasher::METADATA"><code>StorageHasher::METADATA</code></a> for the metadata of the hasher of the
storage item. Thus generic hasher is supported.</p>
<h4 id="macro-expansion-7"><a href="#macro-expansion-7">Macro expansion</a></h4>
<p>For each storage item the macro generates a struct named
<code>_GeneratedPrefixForStorage$NameOfStorage</code>, and implements
<a href="traits/trait.StorageInstance.html"><code>StorageInstance</code></a> on it using the pallet and storage name. It
then uses it as the first generic of the aliased type.
For <code>CountedStorageMap</code>, <code>CountedStorageMapInstance</code> is implemented, and another similar
struct is generated.</p>
<p>For named generic, the macro will reorder the generics, and remove the names.</p>
<p>The macro implements the function <code>storage_metadata</code> on <code>Pallet</code> implementing the metadata
for all storage items based on their kind:</p>
<ul>
<li>for a storage value, the type of the value is copied into the metadata</li>
<li>for a storage map, the type of the values and the key’s type is copied into the metadata</li>
<li>for a storage double map, the type of the values, and the types of key1 and key2 are
copied into the metadata.</li>
</ul>
<h2 id="type-value-pallettype_value-optional"><a href="#type-value-pallettype_value-optional">Type value: <code>#[pallet::type_value]</code> optional</a></h2>
<p>Helper to define a struct implementing <code>Get</code> trait. To ease use of storage types.
This attribute can be used multiple time.</p>
<p>Item is defined as</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::type_value]
</span><span class="kw">fn </span><span class="macro-nonterminal">$MyDefaultName</span>&lt;<span class="macro-nonterminal">$some_generic</span>&gt;() -&gt; <span class="macro-nonterminal">$default_type $optional_where_clause </span>{ <span class="macro-nonterminal">$expr </span>}</code></pre></div>
<p>I.e.: a function definition with generics none or <code>T: Config</code> and a returned type.</p>
<p>E.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::type_value]
</span><span class="kw">fn </span>MyDefault&lt;T: Config&gt;() -&gt; T::Balance { <span class="number">3</span>.into() }</code></pre></div>
<p>NOTE: This attribute is meant to be used alongside <code>#[pallet::storage]</code> to defined some
specific default value in storage.</p>
<h4 id="macro-expansion-8"><a href="#macro-expansion-8">Macro expansion</a></h4>
<p>Macro renames the function to some internal name, generate a struct with the original name
of the function and its generic, and implement <code>Get&lt;$ReturnType&gt;</code> by calling the user
defined function.</p>
<h2 id="genesis-config-palletgenesis_config-optional"><a href="#genesis-config-palletgenesis_config-optional">Genesis config: <code>#[pallet::genesis_config]</code> optional</a></h2>
<p>Allow to define the genesis configuration of the pallet.</p>
<p>Item is defined as either an enum or a struct.
It needs to be public and implement trait GenesisBuild with <code>#[pallet::genesis_build]</code>.
The type generics is constrained to be either none, or <code>T</code> or <code>T: Config</code>.</p>
<p>E.g:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::genesis_config]
</span><span class="kw">pub struct </span>GenesisConfig&lt;T: Config&gt; {
	_myfield: BalanceOf&lt;T&gt;,
}</code></pre></div>
<h4 id="macro-expansion-9"><a href="#macro-expansion-9">Macro expansion</a></h4>
<p>Macro will add the following attribute on it:</p>
<ul>
<li><code>#[cfg(feature = &quot;std&quot;)]</code></li>
<li><code>#[derive(Serialize, Deserialize)]</code></li>
<li><code>#[serde(rename_all = &quot;camelCase&quot;)]</code></li>
<li><code>#[serde(deny_unknown_fields)]</code></li>
<li><code>#[serde(bound(serialize = &quot;&quot;))]</code></li>
<li><code>#[serde(bound(deserialize = &quot;&quot;))]</code></li>
</ul>
<h2 id="genesis-build-palletgenesis_build-optional"><a href="#genesis-build-palletgenesis_build-optional">Genesis build: <code>#[pallet::genesis_build]</code> optional</a></h2>
<p>Allow to define how genesis_configuration is built.</p>
<p>Item is defined as</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::genesis_build]
</span><span class="kw">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="kw">for </span>GenesisConfig&lt;<span class="macro-nonterminal">$maybe_generics</span>&gt; {
	<span class="kw">fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) { <span class="macro-nonterminal">$expr </span>}
}</code></pre></div>
<p>I.e. a rust trait implementation with generic <code>T: Config</code>, of trait <code>GenesisBuild&lt;T&gt;</code> on
type <code>GenesisConfig</code> with generics none or <code>T</code>.</p>
<p>E.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::genesis_build]
</span><span class="kw">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="kw">for </span>GenesisConfig {
	<span class="kw">fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
}</code></pre></div>
<h4 id="macro-expansion-10"><a href="#macro-expansion-10">Macro expansion</a></h4>
<p>Macro will add the following attribute on it:</p>
<ul>
<li><code>#[cfg(feature = &quot;std&quot;)]</code></li>
</ul>
<p>Macro will implement <code>sp_runtime::BuildModuleGenesisStorage</code> using <code>()</code> as second generic
for non-instantiable pallets.</p>
<h2 id="inherent-palletinherent-optional"><a href="#inherent-palletinherent-optional">Inherent: <code>#[pallet::inherent]</code> optional</a></h2>
<p>Allow the pallet to provide some inherent:</p>
<p>Item is defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::inherent]
</span><span class="kw">impl</span>&lt;T: Config&gt; ProvideInherent <span class="kw">for </span>Pallet&lt;T&gt; {
	<span class="comment">// ... regular trait implementation
</span>}</code></pre></div>
<p>I.e. a trait implementation with bound <code>T: Config</code>, of trait <code>ProvideInherent</code> for type
<code>Pallet&lt;T&gt;</code>, and some optional where clause.</p>
<h4 id="macro-expansion-11"><a href="#macro-expansion-11">Macro expansion</a></h4>
<p>Macro make currently no use of this information, but it might use this information in the
future to give information directly to construct_runtime.</p>
<h2 id="validate-unsigned-palletvalidate_unsigned-optional"><a href="#validate-unsigned-palletvalidate_unsigned-optional">Validate unsigned: <code>#[pallet::validate_unsigned]</code> optional</a></h2>
<p>Allow the pallet to validate some unsigned transaction:</p>
<p>Item is defined as:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::validate_unsigned]
</span><span class="kw">impl</span>&lt;T: Config&gt; ValidateUnsigned <span class="kw">for </span>Pallet&lt;T&gt; {
	<span class="comment">// ... regular trait implementation
</span>}</code></pre></div>
<p>I.e. a trait implementation with bound <code>T: Config</code>, of trait <code>ValidateUnsigned</code> for type
<code>Pallet&lt;T&gt;</code>, and some optional where clause.</p>
<p>NOTE: There is also <code>sp_runtime::traits::SignedExtension</code> that can be used to add some
specific logic for transaction validation.</p>
<h4 id="macro-expansion-12"><a href="#macro-expansion-12">Macro expansion</a></h4>
<p>Macro make currently no use of this information, but it might use this information in the
future to give information directly to construct_runtime.</p>
<h2 id="origin-palletorigin-optional"><a href="#origin-palletorigin-optional">Origin: <code>#[pallet::origin]</code> optional</a></h2>
<p>Allow to define some origin for the pallet.</p>
<p>Item must be either a type alias or an enum or a struct. It needs to be public.</p>
<p>E.g.:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::origin]
</span><span class="kw">pub struct </span>Origin&lt;T&gt;(PhantomData&lt;(T)&gt;);</code></pre></div>
<p><strong>WARNING</strong>: modifying origin changes the outer runtime origin. This outer runtime origin
can be stored on-chain (e.g. in pallet-scheduler), thus any change must be done with care
as it might require some migration.</p>
<p>NOTE: for instantiable pallet, origin must be generic over T and I.</p>
<h2 id="general-notes-on-instantiable-pallet"><a href="#general-notes-on-instantiable-pallet">General notes on instantiable pallet</a></h2>
<p>An instantiable pallet is one where Config is generic, i.e. <code>Config&lt;I&gt;</code>. This allow runtime
to implement multiple instance of the pallet, by using different type for the generic.
This is the sole purpose of the generic <code>I</code>.
But because <code>PalletInfo</code> requires <code>Pallet</code> placeholder to be static it is important to
bound <code>'static</code> whenever <code>PalletInfo</code> can be used.
And in order to have instantiable pallet usable as a regular pallet without instance, it is
important to bound <code>= ()</code> on every types.</p>
<p>Thus impl bound look like <code>impl&lt;T: Config&lt;I&gt;, I: 'static&gt;</code>, and types look like
<code>SomeType&lt;T, I=()&gt;</code> or <code>SomeType&lt;T: Config&lt;I&gt;, I: 'static = ()&gt;</code>.</p>
<h2 id="example-for-pallet-without-instance"><a href="#example-for-pallet-without-instance">Example for pallet without instance.</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub use </span>pallet::<span class="kw-2">*</span>; <span class="comment">// reexport in crate namespace for `construct_runtime!`

</span><span class="attr">#[frame_support::pallet]
</span><span class="comment">// NOTE: The name of the pallet is provided by `construct_runtime` and is used as
// the unique identifier for the pallet&#39;s storage. It is not defined in the pallet itself.
</span><span class="kw">pub mod </span>pallet {
	<span class="kw">use </span>frame_support::pallet_prelude::<span class="kw-2">*</span>; <span class="comment">// Import various types used in the pallet definition
	</span><span class="kw">use </span>frame_system::pallet_prelude::<span class="kw-2">*</span>; <span class="comment">// Import some system helper types.

	</span><span class="kw">type </span>BalanceOf&lt;T&gt; = &lt;T <span class="kw">as </span>Config&gt;::Balance;

	<span class="comment">// Define the generic parameter of the pallet
	// The macro parses `#[pallet::constant]` attributes and uses them to generate metadata
	// for the pallet&#39;s constants.
	</span><span class="attr">#[pallet::config]
	</span><span class="kw">pub trait </span>Config: frame_system::Config {
		<span class="attr">#[pallet::constant] </span><span class="comment">// put the constant in metadata
		</span><span class="kw">type </span>MyGetParam: Get&lt;u32&gt;;
		<span class="kw">type </span>Balance: Parameter + MaxEncodedLen + From&lt;u8&gt;;
		<span class="kw">type </span>Event: From&lt;Event&lt;<span class="self">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="self">Self </span><span class="kw">as </span>frame_system::Config&gt;::Event&gt;;
	}

	<span class="comment">// Define some additional constant to put into the constant metadata.
	</span><span class="attr">#[pallet::extra_constants]
	</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
		<span class="doccomment">/// Some description
		</span><span class="kw">fn </span>exra_constant_name() -&gt; u128 { <span class="number">4u128 </span>}
	}

	<span class="comment">// Define the pallet struct placeholder, various pallet function are implemented on it.
	</span><span class="attr">#[pallet::pallet]
	#[pallet::generate_store(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait </span>Store)]
	</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);

	<span class="comment">// Implement the pallet hooks.
	</span><span class="attr">#[pallet::hooks]
	</span><span class="kw">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="kw">for </span>Pallet&lt;T&gt; {
		<span class="kw">fn </span>on_initialize(_n: BlockNumberFor&lt;T&gt;) -&gt; Weight {
			<span class="macro">unimplemented!</span>();
		}

		<span class="comment">// can implement also: on_finalize, on_runtime_upgrade, offchain_worker, ...
		// see `Hooks` trait
	</span>}

	<span class="comment">// Declare Call struct and implement dispatchables.
	//
	// WARNING: Each parameter used in functions must implement: Clone, Debug, Eq, PartialEq,
	// Codec.
	//
	// The macro parses `#[pallet::compact]` attributes on function arguments and implements
	// the `Call` encoding/decoding accordingly.
	</span><span class="attr">#[pallet::call]
	</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
		<span class="doccomment">/// Doc comment put in metadata
		</span><span class="attr">#[pallet::weight(<span class="number">0</span>)] </span><span class="comment">// Defines weight for call (function parameters are in scope)
		</span><span class="kw">pub fn </span>toto(
			origin: OriginFor&lt;T&gt;,
			<span class="attr">#[pallet::compact] </span>_foo: u32,
		) -&gt; DispatchResultWithPostInfo {
			<span class="kw">let _ </span>= origin;
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="comment">// Declare the pallet `Error` enum (this is optional).
	// The macro generates error metadata using the doc comment on each variant.
	</span><span class="attr">#[pallet::error]
	</span><span class="kw">pub enum </span>Error&lt;T&gt; {
		<span class="doccomment">/// doc comment put into metadata
		</span>InsufficientProposersBalance,
	}

	<span class="comment">// Declare pallet Event enum (this is optional).
	//
	// WARNING: Each type used in variants must implement: Clone, Debug, Eq, PartialEq, Codec.
	//
	// The macro generates event metadata, and derive Clone, Debug, Eq, PartialEq and Codec
	</span><span class="attr">#[pallet::event]
	</span><span class="comment">// Generate a funciton on Pallet to deposit an event.
	</span><span class="attr">#[pallet::generate_deposit(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>deposit_event)]
	</span><span class="kw">pub enum </span>Event&lt;T: Config&gt; {
		<span class="doccomment">/// doc comment put in metadata
		</span><span class="comment">// `&lt;T as frame_system::Config&gt;::AccountId` is not defined in metadata list, the last
		// Thus the metadata is `&lt;T as frame_system::Config&gt;::AccountId`.
		</span>Proposed(&lt;T <span class="kw">as </span>frame_system::Config&gt;::AccountId),
		<span class="doccomment">/// doc
		</span><span class="comment">// here metadata will be `Balance` as define in metadata list
		</span>Spending(BalanceOf&lt;T&gt;),
		<span class="comment">// here metadata will be `Other` as define in metadata list
		</span>Something(u32),
	}

	<span class="comment">// Define a struct which implements `frame_support::traits::Get&lt;T::Balance&gt;` (optional).
	</span><span class="attr">#[pallet::type_value]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>MyDefault&lt;T: Config&gt;() -&gt; T::Balance { <span class="number">3</span>.into() }

	<span class="comment">// Declare a storage item. Any amount of storage items can be declared (optional).
	//
	// Is expected either `StorageValue`, `StorageMap` or `StorageDoubleMap`.
	// The macro generates the prefix type and replaces the first generic `_`.
	//
	// The macro expands the metadata for the storage item with the type used:
	// * for a storage value the type of the value is copied into the metadata
	// * for a storage map the type of the values and the type of the key is copied into the metadata
	// * for a storage double map the types of the values and keys are copied into the
	//   metadata.
	//
	// NOTE: The generic `Hasher` must implement the `StorageHasher` trait (or the type is not
	// usable at all). We use [`StorageHasher::METADATA`] for the metadata of the hasher of the
	// storage item. Thus generic hasher is supported.
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorageValue&lt;T: Config&gt; =
		StorageValue&lt;Value = T::Balance, QueryKind = ValueQuery, OnEmpty = MyDefault&lt;T&gt;&gt;;

	<span class="comment">// Another storage declaration
	</span><span class="attr">#[pallet::storage]
	#[pallet::getter(<span class="kw">fn </span>my_storage)]
	#[pallet::storage_prefix = <span class="string">&quot;SomeOtherName&quot;</span>]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; =
		StorageMap&lt;Hasher = Blake2_128Concat, Key = u32, Value = u32&gt;;

	<span class="comment">// Declare the genesis config (optional).
	//
	// The macro accepts either a struct or an enum; it checks that generics are consistent.
	//
	// Type must implement the `Default` trait.
	</span><span class="attr">#[pallet::genesis_config]
	#[derive(Default)]
	</span><span class="kw">pub struct </span>GenesisConfig {
		_myfield: u32,
	}

	<span class="comment">// Declare genesis builder. (This is need only if GenesisConfig is declared)
	</span><span class="attr">#[pallet::genesis_build]
	</span><span class="kw">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="kw">for </span>GenesisConfig {
		<span class="kw">fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
	}

	<span class="comment">// Declare a pallet origin (this is optional).
	//
	// The macro accept type alias or struct or enum, it checks generics are consistent.
	</span><span class="attr">#[pallet::origin]
	</span><span class="kw">pub struct </span>Origin&lt;T&gt;(PhantomData&lt;T&gt;);

	<span class="comment">// Declare validate_unsigned implementation (this is optional).
	</span><span class="attr">#[pallet::validate_unsigned]
	</span><span class="kw">impl</span>&lt;T: Config&gt; ValidateUnsigned <span class="kw">for </span>Pallet&lt;T&gt; {
		<span class="kw">type </span>Call = Call&lt;T&gt;;
		<span class="kw">fn </span>validate_unsigned(
			source: TransactionSource,
			call: <span class="kw-2">&amp;</span><span class="self">Self</span>::Call
		) -&gt; TransactionValidity {
			<span class="prelude-val">Err</span>(TransactionValidityError::Invalid(InvalidTransaction::Call))
		}
	}

	<span class="comment">// Declare inherent provider for pallet (this is optional).
	</span><span class="attr">#[pallet::inherent]
	</span><span class="kw">impl</span>&lt;T: Config&gt; ProvideInherent <span class="kw">for </span>Pallet&lt;T&gt; {
		<span class="kw">type </span>Call = Call&lt;T&gt;;
		<span class="kw">type </span>Error = InherentError;

		<span class="kw">const </span>INHERENT_IDENTIFIER: InherentIdentifier = INHERENT_IDENTIFIER;

		<span class="kw">fn </span>create_inherent(_data: <span class="kw-2">&amp;</span>InherentData) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>::Call&gt; {
			<span class="macro">unimplemented!</span>();
		}

		<span class="kw">fn </span>is_inherent(_call: <span class="kw-2">&amp;</span><span class="self">Self</span>::Call) -&gt; bool {
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="comment">// Regular rust code needed for implementing ProvideInherent trait

	</span><span class="attr">#[derive(codec::Encode, sp_runtime::RuntimeDebug)]
	#[cfg_attr(feature = <span class="string">&quot;std&quot;</span>, derive(codec::Decode))]
	</span><span class="kw">pub enum </span>InherentError {
	}

	<span class="kw">impl </span>sp_inherents::IsFatalError <span class="kw">for </span>InherentError {
		<span class="kw">fn </span>is_fatal_error(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="kw">pub const </span>INHERENT_IDENTIFIER: sp_inherents::InherentIdentifier = <span class="kw-2">*</span><span class="string">b&quot;testpall&quot;</span>;
}</code></pre></div>
<h2 id="example-for-pallet-with-instance"><a href="#example-for-pallet-with-instance">Example for pallet with instance.</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub use </span>pallet::<span class="kw-2">*</span>;

<span class="attr">#[frame_support::pallet]
</span><span class="kw">pub mod </span>pallet {
	<span class="kw">use </span>frame_support::pallet_prelude::<span class="kw-2">*</span>;
	<span class="kw">use </span>frame_system::pallet_prelude::<span class="kw-2">*</span>;

	<span class="kw">type </span>BalanceOf&lt;T, I = ()&gt; = &lt;T <span class="kw">as </span>Config&lt;I&gt;&gt;::Balance;

	<span class="attr">#[pallet::config]
	</span><span class="kw">pub trait </span>Config&lt;I: <span class="lifetime">&#39;static </span>= ()&gt;: frame_system::Config {
		<span class="attr">#[pallet::constant]
		</span><span class="kw">type </span>MyGetParam: Get&lt;u32&gt;;
		<span class="kw">type </span>Balance: Parameter + MaxEncodedLen + From&lt;u8&gt;;
		<span class="kw">type </span>Event: From&lt;Event&lt;<span class="self">Self</span>, I&gt;&gt; + IsType&lt;&lt;<span class="self">Self </span><span class="kw">as </span>frame_system::Config&gt;::Event&gt;;
	}

	<span class="attr">#[pallet::extra_constants]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; Pallet&lt;T, I&gt; {
		<span class="doccomment">/// Some description
		</span><span class="kw">fn </span>exra_constant_name() -&gt; u128 { <span class="number">4u128 </span>}
	}

	<span class="attr">#[pallet::pallet]
	#[pallet::generate_store(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait </span>Store)]
	</span><span class="kw">pub struct </span>Pallet&lt;T, I = ()&gt;(PhantomData&lt;(T, I)&gt;);

	<span class="attr">#[pallet::hooks]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="kw">for </span>Pallet&lt;T, I&gt; {
	}

	<span class="attr">#[pallet::call]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; Pallet&lt;T, I&gt; {
		<span class="doccomment">/// Doc comment put in metadata
		</span><span class="attr">#[pallet::weight(<span class="number">0</span>)]
		</span><span class="kw">pub fn </span>toto(origin: OriginFor&lt;T&gt;, <span class="attr">#[pallet::compact] </span>_foo: u32) -&gt; DispatchResultWithPostInfo {
			<span class="kw">let _ </span>= origin;
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="attr">#[pallet::error]
	</span><span class="kw">pub enum </span>Error&lt;T, I = ()&gt; {
		<span class="doccomment">/// doc comment put into metadata
		</span>InsufficientProposersBalance,
	}

	<span class="attr">#[pallet::event]
	#[pallet::generate_deposit(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>deposit_event)]
	</span><span class="kw">pub enum </span>Event&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static </span>= ()&gt; {
		<span class="doccomment">/// doc comment put in metadata
		</span>Proposed(&lt;T <span class="kw">as </span>frame_system::Config&gt;::AccountId),
		<span class="doccomment">/// doc
		</span>Spending(BalanceOf&lt;T, I&gt;),
		Something(u32),
	}

	<span class="attr">#[pallet::type_value]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>MyDefault&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt;() -&gt; T::Balance { <span class="number">3</span>.into() }

	<span class="attr">#[pallet::storage]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorageValue&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static </span>= ()&gt; =
		StorageValue&lt;Value = T::Balance, QueryKind = ValueQuery, OnEmpty = MyDefault&lt;T, I&gt;&gt;;

	<span class="attr">#[pallet::storage]
	#[pallet::getter(<span class="kw">fn </span>my_storage)]
	#[pallet::storage_prefix = <span class="string">&quot;SomeOtherName&quot;</span>]
	</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T, I = ()&gt; =
		StorageMap&lt;Hasher = Blake2_128Concat, Key = u32, Value = u32&gt;;

	<span class="attr">#[pallet::genesis_config]
	#[derive(Default)]
	</span><span class="kw">pub struct </span>GenesisConfig {
		_myfield: u32,
	}

	<span class="attr">#[pallet::genesis_build]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; GenesisBuild&lt;T, I&gt; <span class="kw">for </span>GenesisConfig {
		<span class="kw">fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
	}

	<span class="attr">#[pallet::origin]
	</span><span class="kw">pub struct </span>Origin&lt;T, I = ()&gt;(PhantomData&lt;(T, I)&gt;);

	<span class="attr">#[pallet::validate_unsigned]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; ValidateUnsigned <span class="kw">for </span>Pallet&lt;T, I&gt; {
		<span class="kw">type </span>Call = Call&lt;T, I&gt;;
		<span class="kw">fn </span>validate_unsigned(
			source: TransactionSource,
			call: <span class="kw-2">&amp;</span><span class="self">Self</span>::Call
		) -&gt; TransactionValidity {
			<span class="prelude-val">Err</span>(TransactionValidityError::Invalid(InvalidTransaction::Call))
		}
	}

	<span class="attr">#[pallet::inherent]
	</span><span class="kw">impl</span>&lt;T: Config&lt;I&gt;, I: <span class="lifetime">&#39;static</span>&gt; ProvideInherent <span class="kw">for </span>Pallet&lt;T, I&gt; {
		<span class="kw">type </span>Call = Call&lt;T, I&gt;;
		<span class="kw">type </span>Error = InherentError;

		<span class="kw">const </span>INHERENT_IDENTIFIER: InherentIdentifier = INHERENT_IDENTIFIER;

		<span class="kw">fn </span>create_inherent(_data: <span class="kw-2">&amp;</span>InherentData) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>::Call&gt; {
			<span class="macro">unimplemented!</span>();
		}

		<span class="kw">fn </span>is_inherent(_call: <span class="kw-2">&amp;</span><span class="self">Self</span>::Call) -&gt; bool {
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="comment">// Regular rust code needed for implementing ProvideInherent trait

	</span><span class="attr">#[derive(codec::Encode, sp_runtime::RuntimeDebug)]
	#[cfg_attr(feature = <span class="string">&quot;std&quot;</span>, derive(codec::Decode))]
	</span><span class="kw">pub enum </span>InherentError {
	}

	<span class="kw">impl </span>sp_inherents::IsFatalError <span class="kw">for </span>InherentError {
		<span class="kw">fn </span>is_fatal_error(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
			<span class="macro">unimplemented!</span>();
		}
	}

	<span class="kw">pub const </span>INHERENT_IDENTIFIER: sp_inherents::InherentIdentifier = <span class="kw-2">*</span><span class="string">b&quot;testpall&quot;</span>;
}</code></pre></div>
<h3 id="upgrade-guidelines"><a href="#upgrade-guidelines">Upgrade guidelines:</a></h3>
<ol>
<li>
<p>Export the metadata of the pallet for later checks</p>
<ul>
<li>run your node with the pallet active</li>
<li>query the metadata using the <code>state_getMetadata</code> RPC and curl, or use <code>subsee -p &lt;PALLET_NAME&gt; &gt; meta.json</code></li>
</ul>
</li>
<li>
<p>generate the template upgrade for the pallet provided by decl_storage
with environment variable <code>PRINT_PALLET_UPGRADE</code>:
<code>PRINT_PALLET_UPGRADE=1 cargo check -p my_pallet</code> This template can be
used as information it contains all information for storages, genesis
config and genesis build.</p>
</li>
<li>
<p>reorganize pallet to have trait <code>Config</code>, <code>decl_*</code> macros, <code>ValidateUnsigned</code>,
<code>ProvideInherent</code>, <code>Origin</code> all together in one file. Suggested order:</p>
<ul>
<li>Config,</li>
<li>decl_module,</li>
<li>decl_event,</li>
<li>decl_error,</li>
<li>decl_storage,</li>
<li>origin,</li>
<li>validate_unsigned,</li>
<li>provide_inherent,
so far it should compile and all be correct.</li>
</ul>
</li>
<li>
<p>start writing the new pallet module</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">pub use </span>pallet::<span class="kw-2">*</span>;

<span class="attr">#[frame_support::pallet]
</span><span class="kw">pub mod </span>pallet {
	<span class="kw">use </span>frame_support::pallet_prelude::<span class="kw-2">*</span>;
	<span class="kw">use </span>frame_system::pallet_prelude::<span class="kw-2">*</span>;
	<span class="kw">use super</span>::<span class="kw-2">*</span>;

	<span class="attr">#[pallet::pallet]
	#[pallet::generate_store(<span class="macro-nonterminal">$visibility_of_trait_store </span><span class="kw">trait </span>Store)]
	</span><span class="comment">// NOTE: if the visibility of trait store is private but you want to make it available
	// in super, then use `pub(super)` or `pub(crate)` to make it available in crate.
	</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);
	<span class="comment">// pub struct Pallet&lt;T, I = ()&gt;(PhantomData&lt;T&gt;); // for instantiable pallet
</span>}</code></pre></div>
</li>
<li>
<p><strong>migrate Config</strong>: move trait into the module with</p>
<ul>
<li>all const in decl_module to <code>#[pallet::constant]</code></li>
<li>add bound <code>IsType&lt;&lt;Self as frame_system::Config&gt;::Event&gt;</code> to <code>type Event</code></li>
</ul>
</li>
<li>
<p><strong>migrate decl_module</strong>: write:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::hooks]
</span><span class="kw">impl</span>&lt;T: Config&gt; Hooks <span class="kw">for </span>Pallet&lt;T&gt; {
}</code></pre></div>
<p>and write inside
<code>on_initialize</code>, <code>on_finalize</code>, <code>on_runtime_upgrade</code>, <code>offchain_worker</code>, <code>integrity_test</code>.</p>
<p>then write:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::call]
</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
}</code></pre></div>
<p>and write inside all the calls in decl_module with a few changes in the signature:</p>
<ul>
<li>origin must now be written completely, e.g. <code>origin: OriginFor&lt;T&gt;</code></li>
<li>result type must be <code>DispatchResultWithPostInfo</code>, you need to write it and also you
might
need to put <code>Ok(().into())</code> at the end or the function.</li>
<li><code>#[compact]</code> must now be written <code>#[pallet::compact]</code></li>
<li><code>#[weight = ..]</code> must now be written <code>#[pallet::weight(..)]</code></li>
</ul>
</li>
<li>
<p><strong>migrate event</strong>:
rewrite as a simple enum under with the attribute <code>#[pallet::event]</code>,
use <code>#[pallet::generate_deposit($vis fn deposit_event)]</code> to generate deposit_event,</p>
</li>
<li>
<p><strong>migrate error</strong>: rewrite it with attribute <code>#[pallet::error]</code>.</p>
</li>
<li>
<p><strong>migrate storage</strong>:
decl_storage provide an upgrade template (see 3.). All storages, genesis config, genesis
build and default implementation of genesis config can be taken from it directly.</p>
<p>Otherwise here is the manual process:</p>
<p>first migrate the genesis logic. write:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::genesis_config]
</span><span class="kw">struct </span>GenesisConfig {
	<span class="comment">// fields of add_extra_genesis
</span>}
<span class="kw">impl </span>Default <span class="kw">for </span>GenesisConfig {
	<span class="comment">// type default or default provided for fields
</span>}
<span class="attr">#[pallet::genesis_build]
</span><span class="kw">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="kw">for </span>GenesisConfig {
<span class="comment">// for instantiable pallet:
// `impl&lt;T: Config, I: &#39;static&gt; GenesisBuild&lt;T, I&gt; for GenesisConfig {
	</span><span class="kw">fn </span>build() {
		<span class="comment">// The add_extra_genesis build logic
	</span>}
}</code></pre></div>
<p>for each storages, if it contains config(..) then add a fields, and make its default to the
value in <code>= ..;</code> or the type default if none, if it contains no build then also add the
logic to build the value.
for each storages if it contains build(..) then add the logic to genesis_build.</p>
<p>NOTE: in decl_storage: is executed first the individual config and build and at the end the
add_extra_genesis build</p>
<p>Once this is done you can migrate storage individually, a few notes:</p>
<ul>
<li>for private storage use <code>pub(crate) type </code> or <code>pub(super) type</code> or nothing,</li>
<li>for storage with <code>get(fn ..)</code> use <code>#[pallet::getter(fn ...)]</code></li>
<li>for storage with value being <code>Option&lt;$something&gt;</code> make generic <code>Value</code> being
<code>$something</code>
and generic <code>QueryKind</code> being <code>OptionQuery</code> (note: this is default). Otherwise make
<code>Value</code> the complete value type and <code>QueryKind</code> being <code>ValueQuery</code>.</li>
<li>for storage with default value: <code>= $expr;</code> provide some specific OnEmpty generic. To do
so
use of <code>#[pallet::type_value]</code> to generate the wanted struct to put.
example: <code>MyStorage: u32 = 3u32</code> would be written:
<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::type_value] </span><span class="kw">fn </span>MyStorageOnEmpty() -&gt; u32 { <span class="number">3u32 </span>}
<span class="attr">#[pallet::storage]
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type </span>MyStorage&lt;T&gt; = StorageValue&lt;<span class="kw">_</span>, u32, ValueQuery, MyStorageOnEmpty&gt;;</code></pre></div>
</li>
</ul>
<p>NOTE: <code>decl_storage</code> also generates functions <code>assimilate_storage</code> and <code>build_storage</code>
directly on GenesisConfig, those are sometimes used in tests. In order not to break they
can be implemented manually, one can implement those functions by calling <code>GenesisBuild</code>
implementation.</p>
</li>
<li>
<p><strong>migrate origin</strong>: move the origin to the pallet module under <code>#[pallet::origin]</code></p>
</li>
<li>
<p><strong>migrate validate_unsigned</strong>: move the <code>ValidateUnsigned</code> implementation to the pallet
module under <code>#[pallet::validate_unsigned]</code></p>
</li>
<li>
<p><strong>migrate provide_inherent</strong>: move the <code>ProvideInherent</code> implementation to the pallet
module under <code>#[pallet::inherent]</code></p>
</li>
<li>
<p>rename the usage of <code>Module</code> to <code>Pallet</code> inside the crate.</p>
</li>
<li>
<p>migration is done, now double check migration with the checking migration guidelines.</p>
</li>
</ol>
<h3 id="checking-upgrade-guidelines"><a href="#checking-upgrade-guidelines">Checking upgrade guidelines:</a></h3>
<ul>
<li>
<p>compare metadata. Use <a href="https://github.com/ascjones/subsee">subsee</a> to fetch the metadata
and do a diff of the resulting json before and after migration. This checks for:</p>
<ul>
<li>call, names, signature, docs</li>
<li>event names, docs</li>
<li>error names, docs</li>
<li>storage names, hasher, prefixes, default value</li>
<li>error , error, constant,</li>
</ul>
</li>
<li>
<p>manually check that:</p>
<ul>
<li><code>Origin</code> is moved inside the macro under <code>#[pallet::origin]</code> if it exists</li>
<li><code>ValidateUnsigned</code> is moved inside the macro under <code>#[pallet::validate_unsigned)]</code> if it
exists</li>
<li><code>ProvideInherent</code> is moved inside macro under <code>#[pallet::inherent)]</code> if it exists</li>
<li><code>on_initialize</code>/<code>on_finalize</code>/<code>on_runtime_upgrade</code>/<code>offchain_worker</code> are moved to
<code>Hooks</code>
implementation</li>
<li>storages with <code>config(..)</code> are converted to <code>GenesisConfig</code> field, and their default is
<code>= $expr;</code> if the storage have default value</li>
<li>storages with <code>build($expr)</code> or <code>config(..)</code> are built in <code>GenesisBuild::build</code></li>
<li><code>add_extra_genesis</code> fields are converted to <code>GenesisConfig</code> field with their correct
default if specified</li>
<li><code>add_extra_genesis</code> build is written into <code>GenesisBuild::build</code></li>
</ul>
</li>
<li>
<p>storage items defined with <a href="attr.pallet.html" title="pallet"><code>pallet</code></a> use the name of the pallet provided by
<a href="traits/trait.PalletInfo.html#tymethod.name" title="traits::PalletInfo::name"><code>traits::PalletInfo::name</code></a> as <code>pallet_prefix</code> (in <code>decl_storage</code>, storage items used the
<code>pallet_prefix</code> given as input of <code>decl_storage</code> with the syntax <code>as Example</code>).
Thus a runtime using the pallet must be careful with this change.
To handle this change:</p>
<ul>
<li>either ensure that the name of the pallet given to <code>construct_runtime!</code> is the same
as the name the pallet was giving to <code>decl_storage</code>,</li>
<li>or do a storage migration from the old prefix used to the new prefix used.</li>
</ul>
<p>NOTE: The prefixes used by storage items are in the metadata. Thus, ensuring the metadata
hasn’t 	changed does ensure that the <code>pallet_prefix</code>s used by the storage items haven’t
changed.</p>
</li>
</ul>
<h2 id="notes-when-macro-fails-to-show-proper-error-message-spans"><a href="#notes-when-macro-fails-to-show-proper-error-message-spans">Notes when macro fails to show proper error message spans:</a></h2>
<p>Rustc loses span for some macro input. Some tips to fix it:</p>
<ul>
<li>do not use inner attribute:
<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet]
</span><span class="kw">pub mod </span>pallet {
	<span class="doccomment">//! This inner attribute will make span fail
	</span>..
}</code></pre></div>
</li>
<li>use the newest nightly possible.
Macro to define a pallet. Docs are at <code>frame_support::pallet</code>.</li>
</ul>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="frame_support" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (234151769 2022-12-03)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>